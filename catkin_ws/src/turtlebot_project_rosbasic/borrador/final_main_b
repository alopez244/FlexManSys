#!/usr/bin/env python

import rospy
from final_publicista_velocidad import CmdVelPub
from turtlebot_project_rosbasic.srv import CrashDirection, CrashDirectionRequest
from std_srvs.srv import Trigger, TriggerRequest

class ControlTurtlebot(object):

    def __init__(self):
        self._kobuki_move = CmdVelPub()
        self.exit_maze()

    def obtain_direction(self):

        # Inicializamos un cliente de servicio
        rospy.wait_for_service('/scan_service')
        obtain_direction_service_client = rospy.ServiceProxy('/scan_service', CrashDirection)
        obtain_direction_request_object = CrashDirectionRequest()
        result = obtain_direction_service_client(obtain_direction_request_object)

        self._direction_command = result.data
        self._kobuki_crashed = result.success

        pass

    def exit_maze(self):
        rospy.init_node('kobuki_salir_maze', anonymous=True)
        self._rate = rospy.Rate(0.2)  # Rate de publicacion de 0.5 Hz, 2 s

        try:

            while not rospy.is_shutdown():  # Creamos un loop

                #kobuki_scan = LaserTopicReader()
                #comando_velocidad = kobuki_scan.crash_detector
                self.obtain_direction()
                self._kobuki_move.move_robot(self._direction_command)
                self._rate.sleep()  # Esperamos a que se cumpla 2s para seguir con el loop.

        except rospy.ROSInterruptException:
            rospy.loginfo('Ejecucion finalizada, Kobuki resting')
            pass

if __name__ == '__main__':

    salir_del_laberinto = ControlTurtlebot()
